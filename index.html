<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>To-do-ADM com IA</title>
    <link rel="icon" type="image/png" href="https://i.ibb.co/mHq3ADF/to-do-list.png">
    <style>
        /* --- GERAL E TEMA --- */
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --surface-hover-color: #2a2a2a;
            --font-color: #e0e0e0;
            --border-color: #333;
            --primary-accent: #0d6efd;
            --primary-accent-hover: #0b5ed7;
            
            --status-aberto: #ffc107;
            --status-andamento: #0d6efd;
            --status-finalizado: #198754;
            --status-aguardando: #6f42c1;

            --priority-alta: #dc3545;
            --priority-media: #ffc107;
            --priority-baixa: #198754;

            --google-blue: #4285F4;
            --google-red: #DB4437;
            --google-yellow: #F4B400;
            --google-green: #0F9D58;

            --ai-glow-start: #00ffff;
            --ai-glow-end: #ff00ff;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--bg-color);
            color: var(--font-color);
            margin: 0;
            padding-top: 60px; /* Espaço para o cabeçalho fixo */
            overflow-x: hidden;
        }

        /* --- CABEÇALHO E MENU SUPERIOR --- */
        header {
            background-color: var(--surface-color);
            border-bottom: 1px solid var(--border-color);
            padding: 0 20px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 1000;
            gap: 15px;
        }

        .header-left, .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--primary-accent);
        }

        .menu-button, .menu-item select, .menu-item input[type="text"] {
            background-color: var(--surface-color);
            color: var(--font-color);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            font-size: 14px;
        }
        .menu-button:hover, .menu-item select:hover { 
            background-color: var(--surface-hover-color);
            border-color: var(--primary-accent);
        }

        .ai-button {
            background: linear-gradient(45deg, var(--ai-glow-start), var(--ai-glow-end));
            color: white;
            border: none;
            box-shadow: 0 0 10px var(--ai-glow-start), 0 0 10px var(--ai-glow-end);
        }
        .ai-button:hover {
            box-shadow: 0 0 15px var(--ai-glow-start), 0 0 15px var(--ai-glow-end);
        }
        
        /* --- Dropdown Menu --- */
        .dropdown {
            position: relative;
            display: inline-block;
        }
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: var(--surface-color);
            min-width: 180px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            right: 0; /* Alinha o dropdown de configurações à direita */
        }
        .dropdown-content .dropdown-item {
            color: var(--font-color);
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            background: none;
            border: none;
            width: 100%;
            text-align: left;
            cursor: pointer;
        }
        .dropdown-content .dropdown-item:hover { background-color: var(--surface-hover-color); }
        .show { display: block; }

        /* Notificações */
        #notificationBtn {
            position: relative;
        }
        #notification-count {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: var(--priority-alta);
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 10px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--surface-color);
        }
        #notification-list {
            max-height: 400px;
            overflow-y: auto;
            min-width: 300px;
        }
        .notification-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
        }
        .notification-item:last-child {
            border-bottom: none;
        }
        .notification-item:hover {
            background-color: var(--surface-hover-color);
        }
        .notification-info {
            flex-grow: 1;
            margin-right: 10px;
        }
        .notification-item p {
            margin: 0 0 2px 0;
            font-size: 0.9em;
        }
        .notification-item small {
            color: #aaa;
        }
        
        /* --- Pesquisa com IA --- */
        .search-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #searchInput.ai-active {
            border-color: transparent;
            background-image: linear-gradient(var(--surface-color), var(--surface-color)), 
                              radial-gradient(circle at top left, var(--google-blue), var(--google-green), var(--google-yellow), var(--google-red));
            background-origin: border-box;
            background-clip: padding-box, border-box;
            animation: bg-spin 3s linear infinite;
        }
        #searchMode {
            -webkit-appearance: none;
            appearance: none;
            width: 40px;
            height: 20px;
            background-color: var(--border-color);
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #searchMode::before {
            content: 'IA';
            color: #000;
            font-size: 10px;
            font-weight: bold;
            position: absolute;
            left: 20px;
            top: 2px;
        }
        #searchMode::after {
            content: '';
            width: 16px;
            height: 16px;
            background-color: white;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }
        #searchMode:checked {
            background-color: var(--google-blue);
        }
        #searchMode:checked::before {
            content: '';
        }
        #searchMode:checked::after {
            transform: translateX(20px);
        }

        /* --- PAINEL KANBAN --- */
        main {
            display: flex;
            gap: 15px;
            padding: 20px;
            min-height: calc(100vh - 100px);
            max-height: calc(100vh - 100px);
            align-items: flex-start;
        }

        .status-column {
            flex: 0 0 320px;
            background-color: var(--surface-color);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            max-height: 100%;
            border-top: 4px solid;
            transition: box-shadow 0.3s;
        }
        .status-column:hover {
            box-shadow: 0 0 20px -5px var(--border-color);
        }

        .column-header {
            padding: 10px 15px;
            font-weight: bold;
            font-size: 1.1em;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ticket-count {
            background-color: var(--surface-hover-color);
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        #column-Aberto { border-color: var(--status-aberto); }
        #column-Andamento { border-color: var(--status-andamento); }
        #column-Finalizado { border-color: var(--status-finalizado); }
        #column-Aguardando { border-color: var(--status-aguardando); }

        .tickets-container {
            overflow-y: auto;
            flex-grow: 1;
            padding: 10px;
        }
        
        /* --- CARTÃO DE TICKET --- */
        .ticket-card {
            background-color: var(--surface-hover-color);
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 5px solid;
            cursor: grab;
            transition: transform 0.2s, box-shadow 0.2s;
            animation: fadeIn 0.5s ease;
        }
        .ticket-card.dragging {
            opacity: 0.5;
            transform: rotate(3deg);
        }
        .ticket-card:hover {
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transform: translateY(-2px);
        }
        
        .ticket-header {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .card-status-select {
            background-color: var(--surface-color);
            color: var(--font-color);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 2px 5px;
            font-size: 0.8em;
            cursor: pointer;
        }
        .card-status-select:hover {
            border-color: var(--primary-accent);
        }

        .ticket-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            font-size: 0.8em;
            color: #aaa;
        }
        
        .footer-left {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .communication-status {
            display: flex;
            gap: 4px; /* Tighter spacing */
        }

        .comm-icon {
            background-color: var(--surface-hover-color);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            transition: transform 0.2s;
        }
        .comm-icon:hover {
            transform: scale(1.1);
        }

        .icon-group {
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: var(--bg-color);
            padding: 2px 6px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }
        .icon-group .copy-icon {
            padding: 2px;
        }
        
        .ticket-priority { padding: 3px 8px; border-radius: 10px; font-size: 0.8em; color: white; font-weight: bold; }
        .ticket-content { margin-bottom: 10px; }
        .ticket-content strong { 
            font-size: 1.05em; 
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: block;
        }
        
        .deadline-wrapper {
            border: 2px solid transparent;
            padding: 2px 5px;
            border-radius: 4px;
            transition: border-color 0.3s;
        }
        .deadline-wrapper.alert {
            animation: pulse-border-red 1.5s infinite;
        }
        .deadline-wrapper.alert span {
            color: var(--priority-alta);
            font-weight: bold;
        }

        /* --- TAGS --- */
        .tags-container {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .tag-item {
            background-color: var(--surface-hover-color);
            border: 1px solid;
            border-radius: 10px;
            padding: 2px 8px;
            font-size: 0.75em;
            font-weight: bold;
        }

        /* --- CHECKLIST / SUB-TAREFAS --- */
        .checklist {
            margin-top: 10px;
        }
        .checklist-progress {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
            color: #ccc;
            margin-bottom: 8px;
        }
        .progress-bar {
            flex-grow: 1;
            height: 6px;
            background-color: var(--border-color);
            border-radius: 3px;
            overflow: hidden;
        }
        .progress-bar-inner {
            height: 100%;
            background-color: var(--primary-accent);
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        .checklist-items {
            max-height: 105px; /* Altura para ~3 itens */
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }
        .checklist-items.expanded {
            max-height: 500px;
        }
        .checklist-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            cursor: pointer;
        }
        .checklist-item input[type="checkbox"] {
            flex-shrink: 0;
        }
        .checklist-item label {
            flex-grow: 1;
            transition: color 0.2s, text-decoration 0.2s;
            white-space: normal;
            word-break: break-word;
            min-width: 0; /* FIX para overflow de texto em flex containers */
        }
        .checklist-item input[type="checkbox"]:checked + label {
            text-decoration: line-through;
            color: #888;
        }
        .toggle-checklist {
            background: none;
            border: none;
            color: var(--primary-accent);
            cursor: pointer;
            font-size: 0.8em;
            margin-top: 5px;
            padding: 0;
            display: block;
            width: 100%;
            text-align: left;
        }
        
        /* --- VISUALIZAÇÃO EM LISTA --- */
        main.list-view {
            flex-direction: column;
            gap: 0;
            max-height: calc(100vh - 60px);
            overflow-y: auto;
            padding: 0;
        }

        .ticket-row {
            background-color: var(--surface-color);
            border-radius: 0;
            padding: 15px 20px;
            border-left: 5px solid;
            display: flex;
            flex-direction: column;
            animation: fadeIn 0.5s ease;
            width: 100%;
            box-sizing: border-box;
            border-bottom: 1px solid var(--border-color);
        }
        .ticket-row:last-child {
            border-bottom: none;
        }
        .ticket-row:hover {
            background-color: var(--surface-hover-color);
        }

        .ticket-row-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            cursor: pointer;
        }

        .ticket-row-left {
            flex-grow: 1;
            display: flex;
            align-items: center;
            gap: 15px;
            min-width: 0;
        }
        .ticket-row-left strong {
            font-size: 1.1em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .ticket-row-right {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .ticket-row-right .checklist-progress {
            margin-bottom: 0;
            width: 120px;
        }

        .ticket-row-bottom {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
        }
        .ticket-row-bottom .checklist-items {
            max-height: 56px; /* Altura para 2 itens */
        }
        .ticket-row-bottom .checklist-items.expanded {
            max-height: 500px;
        }


        /* --- MODAL --- */
        .modal {
            display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.8); animation: fadeIn 0.3s;
        }
        .modal-content {
            background-color: var(--surface-color); margin: 5% auto; padding: 25px; border: 1px solid var(--border-color);
            width: 90%; max-width: 700px; border-radius: 8px; position: relative; box-shadow: 0 5px 25px rgba(0,0,0,0.5);
        }
        .close-button {
            color: #aaa; position: absolute; top: 15px; right: 25px; font-size: 28px; font-weight: bold; cursor: pointer; transition: color 0.2s;
        }
        .close-button:hover { color: white; }
        .modal-content h2 { margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 15px;}
        
        .form-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .form-field { display: flex; flex-direction: column; }
        .form-field.full-width { grid-column: 1 / -1; }
        .form-field label { margin-bottom: 8px; font-size: 0.9em; color: #ccc; }
        .form-field input, .form-field select, .form-field textarea {
            width: 100%; padding: 10px; background-color: var(--bg-color); border: 1px solid var(--border-color);
            color: var(--font-color); border-radius: 4px; box-sizing: border-box; transition: border-color 0.2s;
        }
        #ticketTitle {
            text-transform: capitalize;
        }
        .form-field input:focus, .form-field select:focus, .form-field textarea:focus { outline: none; border-color: var(--primary-accent); }
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            background-color: var(--bg-color);
            padding: 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        .checkbox-group label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        .checkbox-group input {
            width: auto;
            margin-right: 10px;
        }
        .form-buttons { margin-top: 25px; display: flex; justify-content: flex-end; gap: 10px; }
        .form-buttons button { padding: 10px 20px; border-radius: 5px; border: none; cursor: pointer; font-weight: bold; }
        .btn-save { background-color: var(--primary-accent); color: white; }
        .btn-delete { background-color: var(--priority-alta); color: white; }
        .btn-cancel { background-color: var(--surface-hover-color); color: var(--font-color); }
        
        /* Histórico no Modal */
        .modal-extra-section {
            margin-top: 20px; max-height: 150px; overflow-y: auto; padding: 15px; background: var(--bg-color);
            border-radius: 4px; border: 1px solid var(--border-color);
        }
        .modal-extra-section h4 { margin: 0 0 10px 0; }
        .modal-extra-section ul { list-style: none; padding: 0; margin: 0; }
        .modal-extra-section li { font-size: 0.8em; color: #ccc; padding: 5px 0; border-bottom: 1px solid var(--border-color); }
        .modal-extra-section li:last-child { border-bottom: none; }

        /* Ícones de Copiar */
        .copy-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #aaa;
            transition: color 0.2s;
        }
        .copy-icon:hover {
            color: var(--primary-accent);
        }
        .copy-icon.key-icon {
            font-size: 16px;
            color: #FFD700;
        }
        .copy-icon.key-icon:hover {
            color: #FFD700; /* Manter a cor dourada no hover */
        }
        .copy-icon svg {
            width: 16px;
            height: 16px;
        }

        /* Botão Adicionar Flutuante (FAB) */
        .fab {
            position: fixed; bottom: 30px; right: 30px; width: 60px; height: 60px;
            background-color: var(--primary-accent); color: white; border: none; border-radius: 50%;
            font-size: 30px; line-height: 60px; text-align: center; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            cursor: pointer; z-index: 1001; transition: background-color 0.2s, transform 0.2s;
        }
        .fab:hover { background-color: var(--primary-accent-hover); transform: scale(1.05); }

        /* --- ANIMAÇÕES E RESPONSIVIDADE --- */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes pulse-border-red { 0% { border-color: var(--priority-alta); } 50% { border-color: transparent; } 100% { border-color: var(--priority-alta); } }
        @keyframes bg-spin { to { --border-angle: 360deg; } }
        @keyframes flash {
            0% { background-color: var(--primary-accent); }
            100% { background-color: var(--surface-hover-color); }
        }
        .flash {
            animation: flash 1s ease-out;
        }
        
        @keyframes focus-highlight {
            0% { box-shadow: 0 0 0px var(--ai-glow-start); }
            50% { box-shadow: 0 0 25px var(--ai-glow-start); }
            100% { box-shadow: 0 0 0px var(--ai-glow-start); }
        }
        .focus-highlight {
            animation: focus-highlight 2s ease-in-out;
        }
        
        @property --border-angle { syntax: "<angle>"; inherits: true; initial-value: 0deg; }

        @media (max-width: 900px) {
            header { height: auto; padding: 10px; flex-wrap: wrap; justify-content: center; }
            .header-left, .header-right { width: 100%; justify-content: center; }
            body { padding-top: 120px; }
            main { flex-direction: column; }
            .status-column { flex: 1 1 auto; max-height: none; }
        }

    </style>
</head>
<body>

    <!-- CABEÇALHO FIXO -->
    <header>
        <div class="header-left">
            <div class="logo">To-do-ADM</div>
            <div class="dropdown">
                <button class="menu-button dropdown-toggle">Arquivo ▾</button>
                <div class="dropdown-content">
                    <input type="file" id="importFile" accept=".json" style="display: none;">
                    <button id="importBtn" class="dropdown-item">Importar JSON...</button>
                    <select id="exportSelect" class="dropdown-item">
                        <option value="" disabled selected>Exportar como...</option>
                        <option value="json">JSON</option>
                        <option value="csv">CSV</option>
                    </select>
                </div>
            </div>
            <div class="dropdown">
                <button class="menu-button dropdown-toggle ai-button">✨ IA ▾</button>
                <div class="dropdown-content">
                    <button id="generateTagsBtn" class="dropdown-item">Gerar/Atualizar Tags</button>
                    <button id="smartFocusBtn" class="dropdown-item">Foco Inteligente</button>
                </div>
            </div>
        </div>
        <div class="header-right">
            <div class="menu-item">
                <label title="Ordenar por Prioridade" style="font-size: 1.5em; cursor: pointer; display: flex; align-items: center;">
                    <input type="checkbox" id="prioritySortToggle" style="display: none;"> ⇅
                </label>
            </div>
            <div class="search-container">
                <input type="text" id="searchInput" placeholder="Buscar...">
                <input type="checkbox" id="searchMode" title="Ativar busca por IA">
            </div>
            <div class="menu-item">
                <select id="filterStatus">
                    <option value="">Todos Status</option>
                    <option value="Aberto">Aberto</option>
                    <option value="Andamento">Em Andamento</option>
                    <option value="Finalizado">Finalizado</option>
                    <option value="Aguardando">Aguardando</option>
                </select>
            </div>
            <div class="menu-item">
                <label style="font-size: 0.8em; margin-right: 5px; display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="showCompleted" checked> Mostrar Finalizados
                </label>
            </div>
            <div class="dropdown">
                <button id="notificationBtn" class="menu-button dropdown-toggle">
                    🔔
                    <span id="notification-count" style="display: none;">0</span>
                </button>
                <div id="notification-list" class="dropdown-content">
                    <!-- Notificações serão inseridas aqui -->
                </div>
            </div>
            <div class="dropdown">
                <button class="menu-button dropdown-toggle">⚙️</button>
                <div class="dropdown-content">
                    <button id="setApiKeyBtn" class="dropdown-item">Definir Chave de API</button>
                    <button id="autoBackupBtn" class="dropdown-item">Backup Automático...</button>
                    <button id="archiveTasksBtn" class="dropdown-item">Arquivar Concluídas (+30d)</button>
                    <div class="dropdown-item">
                        <label style="cursor: pointer; display: flex; align-items: center; width: 100%;">
                            <input type="checkbox" id="showArchivedToggle" style="margin-right: 10px;"> Ver Arquivados
                        </label>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- PAINEL KANBAN / LISTA -->
    <main id="kanbanBoard"></main>

    <!-- BOTÃO ADICIONAR FLUTUANTE -->
    <button id="addTicketFab" class="fab">+</button>

    <!-- MODAL PARA NOVO/EDITAR TICKET -->
    <div id="ticketModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2 id="modalTitle">Novo Ticket</h2>
            <form id="ticketForm">
                <input type="hidden" id="ticketId">
                <div class="form-grid">
                    <div class="form-field full-width">
                        <label for="ticketTitle">Título do Ticket</label>
                        <input type="text" id="ticketTitle" required maxlength="38">
                    </div>
                    <div class="form-field">
                        <label for="ticketStatus">Status</label>
                        <select id="ticketStatus" required></select>
                    </div>
                     <div class="form-field">
                        <label for="ticketPriority">Prioridade</label>
                        <select id="ticketPriority" required>
                            <option value="Baixa">Baixa</option>
                            <option value="Media">Média</option>
                            <option value="Alta">Alta</option>
                        </select>
                    </div>
                     <div class="form-field">
                        <label for="ticketStartDate">Data de Início</label>
                        <input type="date" id="ticketStartDate" required>
                    </div>
                    <div class="form-field">
                        <label for="ticketDeadline">Prazo Final</label>
                        <input type="date" id="ticketDeadline" required>
                    </div>
                    <div class="form-field">
                        <label for="ticketUser">Usuário</label>
                        <input type="text" id="ticketUser">
                    </div>
                    <div class="form-field">
                        <label for="ticketPassword">Senha</label>
                        <input type="text" id="ticketPassword">
                    </div>
                    <div class="form-field full-width">
                        <label for="ticketSubtasks">Sub-tarefas (uma por linha)</label>
                        <textarea id="ticketSubtasks" rows="4"></textarea>
                    </div>
                    <div class="form-field full-width">
                        <label>Status de Comunicação</label>
                        <div class="checkbox-group">
                            <label><input type="checkbox" id="ticketAviseiRegiana"> Avisei a Regiana</label>
                            <label><input type="checkbox" id="ticketComuniqueiAluno"> Comuniquei o aluno</label>
                            <label><input type="checkbox" id="ticketAguardandoRetorno"> Aguardando retorno do aluno</label>
                        </div>
                    </div>
                </div>
                <div class="form-buttons">
                    <button type="button" id="deleteTicketBtn" class="btn-delete" style="display:none;">Excluir</button>
                    <button type="button" class="btn-cancel">Cancelar</button>
                    <button type="submit" class="btn-save">Salvar</button>
                </div>
            </form>
            <div id="ticket-history" class="modal-extra-section" style="display:none;">
                <h4>Histórico de Alterações</h4>
                <ul id="history-list"></ul>
            </div>
        </div>
    </div>
    
    <!-- MODAL PARA CONFIRMAÇÃO E ALERTAS -->
    <div id="alertModal" class="modal">
        <div class="modal-content" style="max-width: 450px;">
            <span class="close-button">&times;</span>
            <h2 id="alertModalTitle">Atenção</h2>
            <div id="alertModalMessage" style="margin: 20px 0; line-height: 1.5;"></div>
            <div id="alertModalButtons" class="form-buttons">
                <!-- Buttons will be injected here by JS -->
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- VARIÁVEIS E CONSTANTES GLOBAIS ---
            const kanbanBoard = document.getElementById('kanbanBoard');
            const ticketForm = document.getElementById('ticketForm');
            const searchInput = document.getElementById('searchInput');
            const searchMode = document.getElementById('searchMode');
            const filterStatus = document.getElementById('filterStatus');
            const addTicketFab = document.getElementById('addTicketFab');
            const showCompletedCheckbox = document.getElementById('showCompleted');
            const notificationList = document.getElementById('notification-list');
            const notificationCount = document.getElementById('notification-count');
            const prioritySortToggle = document.getElementById('prioritySortToggle');
            const generateTagsBtn = document.getElementById('generateTagsBtn');
            const smartFocusBtn = document.getElementById('smartFocusBtn');
            const archiveTasksBtn = document.getElementById('archiveTasksBtn');
            const showArchivedToggle = document.getElementById('showArchivedToggle');


            let tickets = [];
            let googleApiKey = '';
            let editCount = 0;
            let autoBackupCount = 5; // Default
            const statuses = ['Aberto', 'Andamento', 'Aguardando', 'Finalizado'];
            const statusColors = {
                Aberto: 'var(--status-aberto)', Andamento: 'var(--status-andamento)',
                Finalizado: 'var(--status-finalizado)', Aguardando: 'var(--status-aguardando)',
            };
            const priorityColors = {
                Alta: 'var(--priority-alta)', Media: 'var(--priority-media)', Baixa: 'var(--priority-baixa)',
            };
            const tagColors = ['#4a4e69', '#9a8c98', '#c9ada7', '#f2e9e4', '#22223b'];
            
            // --- FUNÇÕES UTILITÁRIAS ---
            const normalizeText = (text) => {
                if (!text) return '';
                return text
                    .toLowerCase()
                    .normalize("NFD")
                    .replace(/[\u0300-\u036f]/g, "");
            };
            
            const showModal = (title, message, buttons) => {
                return new Promise((resolve) => {
                    const modal = document.getElementById('alertModal');
                    const modalTitle = document.getElementById('alertModalTitle');
                    const modalMessage = document.getElementById('alertModalMessage');
                    const modalButtons = document.getElementById('alertModalButtons');
                    const closeButton = modal.querySelector('.close-button');

                    modalTitle.textContent = title;
                    modalMessage.innerHTML = message;
                    modalButtons.innerHTML = ''; 

                    const closeHandler = (value) => {
                        modal.style.display = 'none';
                        newCloseButton.removeEventListener('click', closeEventHandler);
                        resolve(value);
                    };
                    
                    const closeEventHandler = () => closeHandler(null);

                    const newCloseButton = closeButton.cloneNode(true);
                    closeButton.parentNode.replaceChild(newCloseButton, closeButton);
                    newCloseButton.addEventListener('click', closeEventHandler);

                    buttons.forEach(btnConfig => {
                        const buttonEl = document.createElement('button');
                        buttonEl.textContent = btnConfig.text;
                        buttonEl.className = btnConfig.class;
                        buttonEl.addEventListener('click', () => closeHandler(btnConfig.value));
                        modalButtons.appendChild(buttonEl);
                    });

                    modal.style.display = 'block';
                });
            };


            // --- FUNÇÕES DE LÓGICA DE DADOS ---
            const loadData = () => {
                const data = localStorage.getItem('todo-adm-tickets-v9');
                googleApiKey = localStorage.getItem('todo-adm-google-api-key') || '';
                autoBackupCount = parseInt(localStorage.getItem('todo-adm-autobackup-count') || '5', 10);
                editCount = parseInt(localStorage.getItem('todo-adm-edit-count') || '0', 10);
                tickets = data ? JSON.parse(data).map(normalizeTicket) : [];
                renderNotifications();
            };
            
            const normalizeTicket = (ticket) => {
                let normalized = { ...ticket };

                if (normalized.requirements) {
                    if (typeof normalized.requirements === 'string') {
                        normalized.subtasks = normalized.requirements.split(',')
                            .map(name => name.trim()).filter(name => name)
                            .map(name => ({ name: name, completed: false }));
                    } else if (Array.isArray(normalized.requirements)) {
                        normalized.subtasks = normalized.requirements.map(req => ({
                            name: req.name,
                            completed: req.completed || false
                        }));
                    }
                    delete normalized.requirements;
                }

                if (!normalized.subtasks) normalized.subtasks = [];
                if (!normalized.history) normalized.history = [];
                if (typeof normalized.aviseiRegiana === 'undefined') normalized.aviseiRegiana = false;
                if (typeof normalized.comuniqueiAluno === 'undefined') normalized.comuniqueiAluno = false;
                if (typeof normalized.aguardandoRetorno === 'undefined') normalized.aguardandoRetorno = false;
                if (!normalized.lastSeen) normalized.lastSeen = new Date().toISOString();
                if (!normalized.user) normalized.user = '';
                if (!normalized.password) normalized.password = '';
                if (!normalized.tags) normalized.tags = [];
                if (typeof normalized.archived === 'undefined') normalized.archived = false;
                if (!normalized.completionDate) normalized.completionDate = null;


                return normalized;
            };

            const saveData = (trackEdit = true) => {
                localStorage.setItem('todo-adm-tickets-v9', JSON.stringify(tickets));
                renderNotifications();

                if (trackEdit && autoBackupCount > 0) {
                    editCount++;
                    localStorage.setItem('todo-adm-edit-count', editCount.toString());
                    if (editCount >= autoBackupCount) {
                        handleAutoBackup();
                        editCount = 0; 
                        localStorage.setItem('todo-adm-edit-count', '0');
                    }
                }
            };
            
            const addLogEntry = (ticket, action, user = "Usuário") => {
                if (!ticket.history) ticket.history = [];
                ticket.history.unshift({ action, user, timestamp: new Date().toISOString() });
                if (ticket.history.length > 20) ticket.history.pop();
            };

            // --- RENDERIZAÇÃO DA UI ---
            const toggleUIForView = (isArchivedView) => {
                addTicketFab.style.display = isArchivedView ? 'none' : 'block';
                const controlsToToggle = [filterStatus, showCompletedCheckbox, searchInput, searchMode, prioritySortToggle, generateTagsBtn.parentElement.querySelector('.ai-button')];
                controlsToToggle.forEach(control => {
                    if (control) control.disabled = isArchivedView;
                });

                if (isArchivedView) {
                    filterStatus.value = ''; // Reseta o filtro de status
                }
            };


            const renderBoard = async () => {
                const showArchived = showArchivedToggle.checked;
                toggleUIForView(showArchived);

                const filteredTickets = await getFilteredTickets();
                kanbanBoard.innerHTML = ''; 

                if (showArchived) {
                    kanbanBoard.innerHTML = '<h2 style="padding: 20px 20px 0; color: #aaa;">Tarefas Arquivadas</h2>';
                    renderListView(filteredTickets);
                } else if (filterStatus.value) { 
                    renderListView(filteredTickets.filter(t => t.status === filterStatus.value));
                } else { 
                    renderKanbanView(filteredTickets);
                    setupDragAndDrop();
                }
            };

            const renderKanbanView = (filteredTickets) => {
                kanbanBoard.className = ''; 
                kanbanBoard.style.padding = '20px'; 
                if (filteredTickets.length === 0 && tickets.length > 0 && !showArchivedToggle.checked) {
                    kanbanBoard.innerHTML = '<p style="padding: 20px; color: #aaa;">Nenhum ticket encontrado com os filtros atuais.</p>';
                }
                
                const visibleStatuses = statuses;

                visibleStatuses.forEach(status => {
                    if (!showCompletedCheckbox.checked && status === 'Finalizado') return;
                    
                    const column = document.createElement('div');
                    column.className = 'status-column';
                    column.id = `column-${status.replace(/\s+/g, '')}`;
                    column.dataset.status = status;
                    column.style.borderColor = statusColors[status];

                    const ticketsInColumn = filteredTickets.filter(t => t.status === status);

                    if (prioritySortToggle.checked) {
                        const priorityOrder = { 'Alta': 0, 'Media': 1, 'Baixa': 2 };
                        ticketsInColumn.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
                    }

                    column.innerHTML = `
                        <div class="column-header">
                            <span>${status}</span>
                            <span class="ticket-count">${ticketsInColumn.length}</span>
                        </div>
                        <div class="tickets-container"></div>
                    `;
                    kanbanBoard.appendChild(column);
                    
                    const ticketsContainer = column.querySelector('.tickets-container');
                    ticketsInColumn.forEach(ticket => {
                        const ticketCard = createTicketCard(ticket);
                        ticketsContainer.appendChild(ticketCard);
                    });
                });
            };

            const renderListView = (ticketsToList) => {
                const isArchivedView = showArchivedToggle.checked;
                kanbanBoard.className = 'list-view';
                if(!isArchivedView) kanbanBoard.style.padding = '0'; 
                
                if (ticketsToList.length === 0) {
                     if (!isArchivedView) {
                        kanbanBoard.innerHTML = '<p style="padding: 20px; color: #aaa;">Nenhum ticket encontrado para este status.</p>';
                     }
                    return;
                }

                if (prioritySortToggle.checked && !isArchivedView) {
                    const priorityOrder = { 'Alta': 0, 'Media': 1, 'Baixa': 2 };
                    ticketsToList.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
                }
                
                ticketsToList.forEach(ticket => {
                    const ticketRow = createTicketRow(ticket);
                    kanbanBoard.appendChild(ticketRow);
                });
            };

            const createChecklistHTML = (subtasks, ticketId, isListView = false) => {
                if (!subtasks || subtasks.length === 0) return null;

                const sortedTasks = [...subtasks].sort((a, b) => a.completed - b.completed);
                const completedCount = subtasks.filter(t => t.completed).length;
                const totalCount = subtasks.length;
                const progress = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;

                const itemsHTML = sortedTasks.map((task, index) => `
                    <div class="checklist-item">
                        <input type="checkbox" id="task-${ticketId}-${index}" data-task-name="${task.name}" ${task.completed ? 'checked' : ''}>
                        <label for="task-${ticketId}-${index}">${task.name}</label>
                    </div>
                `).join('');

                const progressHTML = `
                    <div class="checklist-progress">
                        <span>${completedCount}/${totalCount}</span>
                        <div class="progress-bar">
                            <div class="progress-bar-inner" style="width: ${progress}%;"></div>
                        </div>
                    </div>
                `;

                const itemsContainerHTML = `
                    <div class="checklist-items">
                        ${itemsHTML}
                    </div>
                    ${sortedTasks.length > (isListView ? 2 : 3) ? '<button class="toggle-checklist">Ver mais...</button>' : ''}
                `;

                return { progressHTML, itemsContainerHTML };
            };
            
            const createCopyIconHTML = (type, value) => {
                if (type === 'usuário') {
                    const iconSVG = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm2-3a2 2 0 1 1-4 0 2 2 0 0 1 4 0zm4 8c0 1-1 1-1 1H3s-1 0-1-1 1-4 6-4 6 3 6 4zm-1-.004c-.001-.246-.154-.986-.832-1.664C11.516 10.68 10.289 10 8 10c-2.29 0-3.516.68-4.168 1.332-.678.678-.83 1.418-.832 1.664h10z"/></svg>';
                    return `<span class="copy-icon" title="Copiar ${type}" data-copy="${value}">${iconSVG}</span>`;
                } else if (type === 'senha') {
                    return `<span class="copy-icon key-icon" title="Copiar ${type}" data-copy="${value}">🗝️</span>`;
                }
                return '';
            };

            const createTagsHTML = (tags) => {
                if (!tags || tags.length === 0) return '';
                const tagsHTML = tags.map((tag, index) => {
                    const color = tagColors[index % tagColors.length];
                    return `<span class="tag-item" style="border-color: ${color}; color: ${color};">${tag}</span>`;
                }).join('');
                return `<div class="tags-container">${tagsHTML}</div>`;
            };

            const createTicketCard = (ticket) => {
                const card = document.createElement('div');
                card.className = 'ticket-card';
                card.draggable = true;
                card.dataset.id = ticket.id;
                card.style.borderColor = statusColors[ticket.status];

                const now = new Date();
                const deadline = new Date(ticket.deadline);
                const isOverdue = deadline < now && ticket.status !== 'Finalizado';
                const nearingDeadline = !isOverdue && (deadline - now) / (1000 * 3600) <= 24 && ticket.status !== 'Finalizado';
                
                let communicationHTML = '';
                if (ticket.aviseiRegiana || ticket.comuniqueiAluno || ticket.aguardandoRetorno) {
                    communicationHTML += '<div class="communication-status">';
                    if (ticket.aviseiRegiana) communicationHTML += '<span class="comm-icon" title="Regiana foi avisada">R</span>';
                    if (ticket.comuniqueiAluno) communicationHTML += '<span class="comm-icon" title="Aluno comunicado">A</span>';
                    if (ticket.aguardandoRetorno) communicationHTML += '<span class="comm-icon" title="Aguardando retorno do aluno">⏳</span>';
                    communicationHTML += '</div>';
                }

                let iconsHTML = '';
                if (ticket.user) iconsHTML += createCopyIconHTML('usuário', ticket.user);
                if (ticket.password) iconsHTML += createCopyIconHTML('senha', ticket.password);

                const iconGroupContent = iconsHTML + communicationHTML;
                const iconGroupHTML = iconGroupContent ? `<div class="icon-group">${iconGroupContent}</div>` : '';


                const checklist = createChecklistHTML(ticket.subtasks, ticket.id, false);
                const checklistHTML = checklist ? `
                    <div class="checklist">
                        ${checklist.progressHTML}
                        ${checklist.itemsContainerHTML}
                    </div>` : '';
                
                const tagsHTML = createTagsHTML(ticket.tags);


                card.innerHTML = `
                    <div class="ticket-header">
                        <select data-id="${ticket.id}" class="card-status-select">
                            ${statuses.map(s => `<option value="${s}" ${s === ticket.status ? 'selected' : ''}>${s}</option>`).join('')}
                        </select>
                        <span class="ticket-priority" style="background-color: ${priorityColors[ticket.priority]}">${ticket.priority}</span>
                    </div>
                    <div class="ticket-content">
                        <strong>${ticket.title}</strong>
                        ${checklistHTML}
                        ${tagsHTML}
                    </div>
                    <div class="ticket-footer">
                        <div class="footer-left">
                           ${iconGroupHTML}
                           <span class="last-seen">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/><path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/></svg>
                                <span class="last-seen-text">${formatTimeAgo(ticket.lastSeen)}</span>
                           </span>
                        </div>
                        <div class="deadline-wrapper ${isOverdue || nearingDeadline ? 'alert' : ''}">
                            <span>Prazo: ${new Date(ticket.deadline).toLocaleDateString()}</span>
                        </div>
                    </div>
                `;
                
                card.querySelector('.card-status-select').addEventListener('click', (e) => e.stopPropagation());
                card.querySelector('.card-status-select').addEventListener('change', handleQuickStatusChange);

                card.addEventListener('click', (e) => {
                    if (e.target.closest('.copy-icon')) {
                        return;
                    }
                    if (e.target.classList.contains('toggle-checklist')) {
                         e.stopPropagation();
                         const container = e.target.previousElementSibling;
                         container.classList.toggle('expanded');
                         e.target.textContent = container.classList.contains('expanded') ? 'Ver menos' : 'Ver mais...';
                    } else if (e.target.matches('.checklist-item, .checklist-item *')) {
                        e.stopPropagation();
                        const item = e.target.closest('.checklist-item');
                        const checkbox = item.querySelector('input[type="checkbox"]');
                        if (e.target !== checkbox) {
                            checkbox.checked = !checkbox.checked;
                        }
                        handleSubtaskCheck(ticket.id, checkbox.dataset.taskName, checkbox.checked);
                    } else {
                        handleMarkAsSeen(ticket.id);
                        openModal('ticketModal', ticket.id);
                    }
                });

                return card;
            };

            const createTicketRow = (ticket) => {
                const row = document.createElement('div');
                row.className = 'ticket-row';
                row.dataset.id = ticket.id;
                row.style.borderColor = statusColors[ticket.status];

                const now = new Date();
                const deadline = new Date(ticket.deadline);
                const isOverdue = deadline < now && ticket.status !== 'Finalizado' && !ticket.archived;
                const nearingDeadline = !isOverdue && (deadline - now) / (1000 * 3600) <= 24 && ticket.status !== 'Finalizado' && !ticket.archived;

                let communicationHTML = '';
                if (ticket.aviseiRegiana || ticket.comuniqueiAluno || ticket.aguardandoRetorno) {
                    communicationHTML += '<div class="communication-status">';
                    if (ticket.aviseiRegiana) communicationHTML += '<span class="comm-icon" title="Regiana foi avisada">R</span>';
                    if (ticket.comuniqueiAluno) communicationHTML += '<span class="comm-icon" title="Aluno comunicado">A</span>';
                    if (ticket.aguardandoRetorno) communicationHTML += '<span class="comm-icon" title="Aguardando retorno do aluno">⏳</span>';
                    communicationHTML += '</div>';
                }

                let iconsHTML = '';
                if (ticket.user) iconsHTML += createCopyIconHTML('usuário', ticket.user);
                if (ticket.password) iconsHTML += createCopyIconHTML('senha', ticket.password);

                const iconGroupContent = iconsHTML + communicationHTML;
                const iconGroupHTML = iconGroupContent ? `<div class="icon-group">${iconGroupContent}</div>` : '';

                const checklist = createChecklistHTML(ticket.subtasks, ticket.id, true);
                const checklistProgressHTML = checklist ? checklist.progressHTML : '<div style="width: 120px;"></div>'; // Placeholder for alignment
                
                const tagsHTML = createTagsHTML(ticket.tags);

                const bottomContent = (checklist ? checklist.itemsContainerHTML : '') + tagsHTML;
                const checklistItemsHTML = bottomContent ? `<div class="ticket-row-bottom">${bottomContent}</div>` : '';


                row.innerHTML = `
                    <div class="ticket-row-top">
                        <div class="ticket-row-left">
                            <strong>${ticket.title}</strong>
                        </div>
                        <div class="ticket-row-right">
                            ${iconGroupHTML}
                            ${checklistProgressHTML}
                            <span class="last-seen" title="Última visualização">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/><path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/></svg>
                                <span class="last-seen-text">${formatTimeAgo(ticket.lastSeen)}</span>
                            </span>
                            <span class="ticket-priority" style="background-color: ${priorityColors[ticket.priority]}">${ticket.priority}</span>
                            <div class="deadline-wrapper ${isOverdue || nearingDeadline ? 'alert' : ''}">
                                <span>${ticket.archived ? `Concluído: ${new Date(ticket.completionDate).toLocaleDateString()}` : `Prazo: ${new Date(ticket.deadline).toLocaleDateString()}`}</span>
                            </div>
                            <select data-id="${ticket.id}" class="card-status-select" ${ticket.archived ? 'disabled' : ''}>
                                ${statuses.map(s => `<option value="${s}" ${s === ticket.status ? 'selected' : ''}>${s}</option>`).join('')}
                            </select>
                        </div>
                    </div>
                    ${checklistItemsHTML}
                `;

                row.querySelector('.ticket-row-top').addEventListener('click', (e) => {
                    if (e.target.closest('.card-status-select, .comm-icon, .copy-icon, .toggle-checklist')) {
                        return;
                    }
                    handleMarkAsSeen(ticket.id);
                    openModal('ticketModal', ticket.id);
                });

                row.querySelector('.card-status-select').addEventListener('change', handleQuickStatusChange);

                if (checklist) {
                    const toggleBtn = row.querySelector('.toggle-checklist');
                    if (toggleBtn) {
                        toggleBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const container = row.querySelector('.checklist-items');
                            container.classList.toggle('expanded');
                            toggleBtn.textContent = container.classList.contains('expanded') ? 'Ver menos' : 'Ver mais...';
                        });
                    }
                    row.querySelectorAll('.checklist-item').forEach(item => {
                        item.addEventListener('click', e => {
                            e.stopPropagation();
                            const checkbox = item.querySelector('input[type="checkbox"]');
                            if (e.target !== checkbox) checkbox.checked = !checkbox.checked;
                            handleSubtaskCheck(ticket.id, checkbox.dataset.taskName, checkbox.checked);
                        });
                    });
                }

                return row;
            };

            const getFilteredTickets = async () => {
                const showArchived = showArchivedToggle.checked;
                let baseTickets = tickets.filter(t => t.archived === showArchived);

                if (showArchived) {
                    baseTickets.sort((a, b) => new Date(b.completionDate) - new Date(a.completionDate));
                    return baseTickets;
                }

                const normalizedSearchTerm = normalizeText(searchInput.value);
                
                if (searchMode.checked && normalizedSearchTerm) {
                    searchInput.disabled = true;
                    searchInput.placeholder = 'Pesquisando com IA...';
                    try {
                        const aiFilteredIds = await performAISearch(normalizedSearchTerm, baseTickets);
                        baseTickets = baseTickets.filter(t => aiFilteredIds.includes(t.id));
                    } catch (error) {
                        await showModal('Erro na Busca', `Erro na busca com IA: ${error.message}`, [{ text: 'OK', value: 'ok', class: 'btn-cancel' }]);
                    } finally {
                        searchInput.disabled = false;
                        searchInput.placeholder = 'Buscar...';
                    }
                } else if (normalizedSearchTerm) {
                    baseTickets = baseTickets.filter(ticket => 
                        (normalizeText(ticket.title).includes(normalizedSearchTerm)) ||
                        (ticket.subtasks && ticket.subtasks.some(r => normalizeText(r.name).includes(normalizedSearchTerm)))
                    );
                }

                return baseTickets.filter(ticket => {
                    return showCompletedCheckbox.checked || ticket.status !== 'Finalizado';
                });
            };

            // --- LÓGICA DE IA ---
            const performAISearch = async (query, ticketsToSearch) => {
                if (!googleApiKey) throw new Error("Chave de API do Google não definida. Por favor, defina nas configurações.");
                
                const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${googleApiKey}`;
                
                const simplifiedTickets = ticketsToSearch.map(({ id, title, subtasks, priority, deadline }) => ({ 
                    id, 
                    title, 
                    subtasks: subtasks.map(r => r.name).join(', '), 
                    priority, 
                    deadline 
                }));

                const prompt = `Você é um assistente de kanban. Analise as tarefas JSON. A data atual é ${new Date().toLocaleDateString()}. Pesquisa do usuário: "${query}". Retorne um array JSON com os IDs das tarefas mais relevantes. Lista: ${JSON.stringify(simplifiedTickets)}. Responda apenas com o array de IDs.`;

                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }], generationConfig: { response_mime_type: "application/json" } })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error.message || "Erro na API do Google.");
                }

                const data = await response.json();
                return JSON.parse(data.candidates[0].content.parts[0].text);
            };

            const generateTagsForTicket = async (ticket) => {
                if (!googleApiKey) {
                    console.error("Chave de API do Google não definida.");
                    return;
                }

                const pendingSubtasks = ticket.subtasks.filter(st => !st.completed).map(st => st.name);
                if (pendingSubtasks.length === 0) {
                    ticket.tags = [];
                    return;
                }
                
                const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${googleApiKey}`;
                const subtasksText = pendingSubtasks.join(', ');
                const prompt = `Analise a seguinte lista de tarefas pendentes: "${subtasksText}". Com base nelas, gere até 4 tags curtas de uma ou duas palavras que resumam os temas principais. Retorne as tags em um array JSON. Exemplo: ["Contrato", "Financeiro", "Documentação"]`;

                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }], generationConfig: { response_mime_type: "application/json" } })
                    });
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error.message || "Erro ao gerar tags.");
                    }
                    const data = await response.json();
                    const newTags = JSON.parse(data.candidates[0].content.parts[0].text);
                    if (Array.isArray(newTags)) {
                        ticket.tags = newTags;
                    }
                } catch (error) {
                    console.error(`Erro ao gerar tags para o ticket ${ticket.id}:`, error);
                }
            };

            const handleSmartFocus = async () => {
                if (!googleApiKey) {
                    await showModal('Aviso', 'Por favor, defina sua Chave de API do Google nas configurações (⚙️) antes de usar as funções de IA.', [{ text: 'OK', value: 'ok', class: 'btn-cancel' }]);
                    return;
                }

                const activeTickets = tickets.filter(t => t.status !== 'Finalizado' && !t.archived);

                if (activeTickets.length === 0) {
                    await showModal('Foco Inteligente', 'Parabéns! Você não tem nenhuma tarefa ativa para focar.', [{ text: 'OK', value: 'ok', class: 'btn-save' }]);
                    return;
                }

                smartFocusBtn.textContent = 'Analisando...';
                smartFocusBtn.disabled = true;

                try {
                    const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${googleApiKey}`;
                    const simplifiedTickets = activeTickets.map(({ id, title, priority, deadline, status }) => ({ id, title, priority, deadline, status }));
                    const today = new Date().toISOString().split('T')[0];
                    const prompt = `Você é um assistente de produtividade. A data de hoje é ${today}. Com base na lista de tarefas a seguir, qual é a tarefa MAIS IMPORTANTE que o usuário deve focar agora? Considere a prioridade mais alta e o prazo mais próximo como fatores principais. Retorne APENAS o 'id' da tarefa sugerida em formato JSON, como {"id": "12345"}. Lista de tarefas: ${JSON.stringify(simplifiedTickets)}`;

                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }], generationConfig: { response_mime_type: "application/json" } })
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error.message || "Erro na API.");
                    }

                    const data = await response.json();
                    const result = JSON.parse(data.candidates[0].content.parts[0].text);
                    const recommendedId = result.id;
                    
                    if (showArchivedToggle.checked) {
                        showArchivedToggle.checked = false;
                        await renderBoard();
                    }
                    
                    const cardToHighlight = document.querySelector(`.ticket-card[data-id="${recommendedId}"], .ticket-row[data-id="${recommendedId}"]`);
                    
                    if (cardToHighlight) {
                        cardToHighlight.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        cardToHighlight.classList.add('focus-highlight');
                        setTimeout(() => cardToHighlight.classList.remove('focus-highlight'), 2000);
                    } else {
                         const recommendedTicket = tickets.find(t => t.id === recommendedId);
                         await showModal('Foco Inteligente', `A próxima tarefa sugerida é: "${recommendedTicket.title}". Ela não está visível na sua visualização atual.`, [{ text: 'OK', value: 'ok', class: 'btn-cancel' }]);
                    }

                } catch (error) {
                    await showModal('Erro', `Não foi possível sugerir uma tarefa: ${error.message}`, [{ text: 'OK', value: 'ok', class: 'btn-cancel' }]);
                } finally {
                    smartFocusBtn.textContent = 'Foco Inteligente';
                    smartFocusBtn.disabled = false;
                }
            };


            // --- NOTIFICAÇÕES ---
            const renderNotifications = () => {
                notificationList.innerHTML = '';
                const now = new Date();
                let count = 0;

                const urgentTickets = tickets.filter(ticket => {
                    if (ticket.status === 'Finalizado' || ticket.archived) return false;
                    const deadline = new Date(ticket.deadline);
                    const hoursRemaining = (deadline - now) / (1000 * 3600);
                    return hoursRemaining <= 24;
                });

                if (urgentTickets.length === 0) {
                    notificationList.innerHTML = '<div class="notification-item"><p>Nenhuma notificação</p></div>';
                    notificationCount.style.display = 'none';
                    return;
                }

                urgentTickets.sort((a, b) => new Date(a.deadline) - new Date(b.deadline));

                urgentTickets.forEach(ticket => {
                    const deadline = new Date(ticket.deadline);
                    const isOverdue = deadline < now;
                    const message = isOverdue ? 'Ticket Atrasado!' : 'Vence em menos de 24h!';
                    
                    const item = document.createElement('div');
                    item.className = 'notification-item';
                    item.dataset.ticketId = ticket.id;
                    item.innerHTML = `
                        <div class="notification-info">
                            <p><strong>${ticket.title}</strong></p>
                            <small style="color: ${isOverdue ? 'var(--priority-alta)' : 'var(--status-aberto)'}">${message}</small>
                        </div>
                        <select data-id="${ticket.id}" class="card-status-select">
                            ${statuses.map(s => `<option value="${s}" ${s === ticket.status ? 'selected' : ''}>${s}</option>`).join('')}
                        </select>
                    `;
                    notificationList.appendChild(item);
                });

                count = urgentTickets.length;
                notificationCount.textContent = count;
                notificationCount.style.display = count > 0 ? 'flex' : 'none';
            };

            const requestNotificationPermission = () => {
                if ('Notification' in window && Notification.permission !== 'granted' && Notification.permission !== 'denied') {
                    Notification.requestPermission();
                }
            };

            const checkDeadlinesForDesktop = () => {
                const now = new Date();
                tickets.forEach(ticket => {
                    if (ticket.status === 'Finalizado' || ticket.archived) return;
                    const deadline = new Date(ticket.deadline);
                    const hoursRemaining = (deadline - now) / (1000 * 3600);
                    if (hoursRemaining > 0 && hoursRemaining <= 24) {
                        showDesktopNotification(`Ticket próximo do prazo: "${ticket.title}"`, `O prazo termina em menos de 24 horas.`);
                    }
                });
            };

            const showDesktopNotification = (title, body) => {
                if ('Notification' in window && Notification.permission === 'granted') {
                    new Notification(title, { body });
                }
            };

            // --- MODAL E FORMULÁRIOS ---
            const openModal = (modalId, ticketId = null) => {
                const modal = document.getElementById(modalId);
                if (modalId === 'ticketModal') setupTicketModal(ticketId);
                modal.style.display = 'block';
            };

            const closeModal = (modalId) => document.getElementById(modalId).style.display = 'none';

            const setupTicketModal = (ticketId) => {
                ticketForm.reset();
                document.getElementById('ticket-history').style.display = 'none';
                document.getElementById('ticketStatus').innerHTML = statuses.map(s => `<option value="${s}">${s}</option>`).join('');

                if (ticketId) {
                    const ticket = tickets.find(t => t.id === ticketId);
                    document.getElementById('modalTitle').textContent = 'Editar Ticket';
                    
                    document.getElementById('ticketId').value = ticket.id;
                    document.getElementById('ticketTitle').value = ticket.title;
                    document.getElementById('ticketStatus').value = ticket.status;
                    document.getElementById('ticketPriority').value = ticket.priority;
                    document.getElementById('ticketStartDate').value = ticket.startDate;
                    document.getElementById('ticketDeadline').value = ticket.deadline;
                    document.getElementById('ticketUser').value = ticket.user || '';
                    document.getElementById('ticketPassword').value = ticket.password || '';
                    document.getElementById('ticketAviseiRegiana').checked = ticket.aviseiRegiana;
                    document.getElementById('ticketComuniqueiAluno').checked = ticket.comuniqueiAluno;
                    document.getElementById('ticketAguardandoRetorno').checked = ticket.aguardandoRetorno;
                    
                    if (Array.isArray(ticket.subtasks)) {
                        document.getElementById('ticketSubtasks').value = ticket.subtasks.map(r => r.name).join('\n');
                    } else {
                         document.getElementById('ticketSubtasks').value = '';
                    }

                    if (ticket.history?.length > 0) renderHistoryInModal(ticket.history);
                    document.getElementById('deleteTicketBtn').style.display = 'inline-block';
                } else {
                    document.getElementById('modalTitle').textContent = 'Novo Ticket';
                    document.getElementById('ticketId').value = '';
                    document.getElementById('ticketStartDate').value = new Date().toISOString().split('T')[0];
                    document.getElementById('deleteTicketBtn').style.display = 'none';
                }
            };
            
            const renderHistoryInModal = (history) => {
                const historyContainer = document.getElementById('ticket-history');
                historyContainer.style.display = 'block';
                document.getElementById('history-list').innerHTML = history.map(log => 
                    `<li>${new Date(log.timestamp).toLocaleString()}: ${log.action} (por ${log.user})</li>`
                ).join('');
            };

            // --- HANDLERS DE EVENTOS ---
            const capitalizeWords = (str) => {
                return str.toLowerCase().replace(/\b\w/g, char => char.toUpperCase());
            };

            const handleFormSubmit = async (e) => {
                e.preventDefault();
                const id = document.getElementById('ticketId').value;
                const newTitle = capitalizeWords(document.getElementById('ticketTitle').value.trim());

                const normalizedNewTitle = newTitle.toLowerCase();
                const isDuplicate = tickets.some(ticket => 
                    ticket.id !== id && 
                    ticket.title.toLowerCase() === normalizedNewTitle &&
                    !ticket.archived
                );

                if (isDuplicate) {
                    await showModal('Título Duplicado', 'Já existe um card ativo com este título. Por favor, use um título diferente.', [{ text: 'OK', value: 'ok', class: 'btn-cancel' }]);
                    return;
                }
                
                const originalTicket = id ? { ...tickets.find(t => t.id === id) } : null;
                
                const newSubtasksString = document.getElementById('ticketSubtasks').value.trim();
                const newSubtasksNames = newSubtasksString.split('\n').map(name => name.trim()).filter(name => name);
                
                const newSubtasks = newSubtasksNames.map(name => {
                    const existingTask = originalTicket?.subtasks.find(r => r.name === name);
                    return { name: name, completed: existingTask ? existingTask.completed : false };
                });

                const ticketData = {
                    id: id || Date.now().toString(),
                    title: newTitle,
                    status: document.getElementById('ticketStatus').value,
                    startDate: document.getElementById('ticketStartDate').value,
                    deadline: document.getElementById('ticketDeadline').value,
                    priority: document.getElementById('ticketPriority').value,
                    user: document.getElementById('ticketUser').value.trim(),
                    password: document.getElementById('ticketPassword').value.trim(),
                    subtasks: newSubtasks,
                    aviseiRegiana: document.getElementById('ticketAviseiRegiana').checked,
                    comuniqueiAluno: document.getElementById('ticketComuniqueiAluno').checked,
                    aguardandoRetorno: document.getElementById('ticketAguardandoRetorno').checked,
                    history: originalTicket?.history || [],
                    tags: originalTicket?.tags || [],
                    archived: originalTicket?.archived || false,
                    lastSeen: new Date().toISOString()
                };

                // Lógica de Data de Conclusão
                if (originalTicket && originalTicket.status !== 'Finalizado' && ticketData.status === 'Finalizado') {
                    ticketData.completionDate = new Date().toISOString();
                } else if (originalTicket && originalTicket.status === 'Finalizado' && ticketData.status !== 'Finalizado') {
                    ticketData.completionDate = null;
                } else {
                    ticketData.completionDate = originalTicket?.completionDate || null;
                }


                await generateTagsForTicket(ticketData);

                if (id) {
                    const index = tickets.findIndex(t => t.id === id);
                    const changes = getChanges(originalTicket, ticketData);
                    if (changes) addLogEntry(ticketData, `Ticket editado: ${changes}`);
                    tickets[index] = ticketData;
                } else {
                    addLogEntry(ticketData, 'Ticket criado.');
                    tickets.push(ticketData);
                }
                saveData();
                renderBoard();
                closeModal('ticketModal');
            };
            
            const getChanges = (oldT, newT) => Object.keys(newT).filter(key => key !== 'history' && JSON.stringify(oldT[key]) !== JSON.stringify(newT[key])).map(key => `${key} alterado`).join(', ');

            const handleDeleteTicket = async () => {
                const choice = await showModal(
                    'Excluir Ticket',
                    'Tem certeza que deseja excluir este ticket? Esta ação não pode ser desfeita.',
                    [
                        { text: 'Excluir', value: 'delete', class: 'btn-delete' },
                        { text: 'Cancelar', value: null, class: 'btn-cancel' }
                    ]
                );

                if (choice === 'delete') {
                    const id = document.getElementById('ticketId').value;
                    tickets = tickets.filter(t => t.id !== id);
                    saveData();
                    renderBoard();
                    closeModal('ticketModal');
                }
            };
            
            const handleSetApiKey = async () => {
                const message = `
                    <p>Insira sua chave de API do Google AI Studio:</p>
                    <input type="text" id="apiKeyInput" class="form-field" style="width: 100%; margin-top: 10px;" value="${googleApiKey}">
                `;
                const choice = await showModal(
                    'Definir Chave de API',
                    message,
                    [
                        { text: 'Salvar', value: 'save', class: 'btn-save' },
                        { text: 'Cancelar', value: null, class: 'btn-cancel' }
                    ]
                );

                if (choice === 'save') {
                    const key = document.getElementById('apiKeyInput').value;
                    if (key !== null) {
                        googleApiKey = key.trim();
                        localStorage.setItem('todo-adm-google-api-key', googleApiKey);
                        await showModal('Sucesso', 'Chave de API salva com sucesso!', [{ text: 'OK', value: 'ok', class: 'btn-save' }]);
                    }
                }
            };

            const handleQuickStatusChange = (e) => {
                e.stopPropagation();
                const ticketId = e.target.dataset.id;
                const newStatus = e.target.value;
                const ticketToUpdate = tickets.find(t => t.id === ticketId);

                if (ticketToUpdate && ticketToUpdate.status !== newStatus) {
                    addLogEntry(ticketToUpdate, `Status alterado de "${ticketToUpdate.status}" para "${newStatus}"`);
                    const oldStatus = ticketToUpdate.status;
                    ticketToUpdate.status = newStatus;

                    if (newStatus === 'Finalizado' && oldStatus !== 'Finalizado') {
                        ticketToUpdate.completionDate = new Date().toISOString();
                    } else if (newStatus !== 'Finalizado' && oldStatus === 'Finalizado') {
                        ticketToUpdate.completionDate = null;
                    }

                    updateLastSeenTimestamp(ticketToUpdate);
                    saveData();
                    renderBoard();
                }
            };

            const handleSubtaskCheck = async (ticketId, taskName, isChecked) => {
                const ticket = tickets.find(t => t.id === ticketId);
                if (!ticket) return;

                const task = ticket.subtasks.find(r => r.name === taskName);
                if (!task) return;

                task.completed = isChecked;
                addLogEntry(ticket, `Sub-tarefa "${taskName}" marcada como ${task.completed ? 'concluída' : 'pendente'}.`);
                updateLastSeenTimestamp(ticket);
                
                await generateTagsForTicket(ticket); // Atualiza as tags
                saveData();

                const currentElement = document.querySelector(`.ticket-card[data-id="${ticketId}"], .ticket-row[data-id="${ticketId}"]`);
                if (currentElement) {
                    let newElement;
                    if (currentElement.classList.contains('ticket-card')) {
                        newElement = createTicketCard(ticket);
                    } else {
                        newElement = createTicketRow(ticket);
                    }
                    currentElement.replaceWith(newElement);
                } else {
                    renderBoard();
                }
            };

            const handleMarkAsSeen = (ticketId) => {
                const ticket = tickets.find(t => t.id === ticketId);
                if (ticket) {
                    updateLastSeenTimestamp(ticket);
                    saveData(false); 
                    const currentElement = document.querySelector(`.ticket-card[data-id="${ticketId}"], .ticket-row[data-id="${ticketId}"]`);
                    if (currentElement) {
                        const lastSeenEl = currentElement.querySelector('.last-seen-text');
                        if (lastSeenEl) {
                            lastSeenEl.textContent = formatTimeAgo(ticket.lastSeen);
                        }
                    }
                }
            };
            
            const updateLastSeenTimestamp = (ticket) => {
                if (ticket) {
                    ticket.lastSeen = new Date().toISOString();
                }
            };

            // --- DRAG & DROP, IMPORT/EXPORT, BACKUP ---
            const setupDragAndDrop = () => {
                document.querySelectorAll('.ticket-card').forEach(card => {
                    card.addEventListener('dragstart', e => e.target.classList.add('dragging'));
                    card.addEventListener('dragend', e => e.target.classList.remove('dragging'));
                });
                document.querySelectorAll('.status-column').forEach(column => {
                    column.addEventListener('dragover', e => { e.preventDefault(); });
                    column.addEventListener('drop', e => {
                        e.preventDefault();
                        const cardId = document.querySelector('.dragging')?.dataset.id;
                        if (!cardId) return;
                        const ticket = tickets.find(t => t.id === cardId);
                        const newStatus = column.dataset.status;
                        if (ticket.status !== newStatus) {
                            addLogEntry(ticket, `Status movido de "${ticket.status}" para "${newStatus}"`);
                            const oldStatus = ticket.status;
                            ticket.status = newStatus;

                            if (newStatus === 'Finalizado' && oldStatus !== 'Finalizado') {
                                ticket.completionDate = new Date().toISOString();
                            } else if (newStatus !== 'Finalizado' && oldStatus === 'Finalizado') {
                                ticket.completionDate = null;
                            }

                            updateLastSeenTimestamp(ticket);
                            saveData();
                            renderBoard();
                        }
                    });
                });
            };

            const handleExport = async (format) => {
                if (tickets.length === 0) {
                    await showModal('Aviso', 'Nenhum ticket para exportar.', [{ text: 'OK', value: 'ok', class: 'btn-cancel' }]);
                    return;
                }
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `todo-adm-backup-${timestamp}.${format}`;
                let content, mimeType;

                if (format === 'json') {
                    content = JSON.stringify(tickets, null, 2);
                    mimeType = 'application/json';
                } else if (format === 'csv') {
                    const headers = Object.keys(tickets[0] || {}).join(',');
                    const rows = tickets.map(t => {
                        return Object.values(t).map(val => {
                            let value = '';
                            if (typeof val === 'string') {
                                value = val.replace(/"/g, '""');
                            } else if (typeof val === 'object' && val !== null) {
                                value = JSON.stringify(val).replace(/"/g, '""');
                            } else {
                                value = String(val);
                            }
                            return `"${value}"`;
                        }).join(',');
                    });
                    content = `${headers}\n${rows.join('\n')}`;
                    mimeType = 'text/csv;charset=utf-8;';
                }
                if (content) {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(new Blob([content], { type: mimeType }));
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(a.href);
                }
            };

            const handleImport = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (e) => { 
                    try {
                        if (!file.name.endsWith('.json')) {
                            throw new Error('Formato de arquivo não suportado. Use JSON.');
                        }
                        const importedData = JSON.parse(e.target.result);
                        if (!Array.isArray(importedData)) throw new Error('O arquivo JSON não contém um array de tickets válido.');
                        
                        const importedTickets = importedData.map(normalizeTicket);

                        const mergeChoice = await showModal(
                            'Importar Tickets', 
                            'Deseja mesclar os tickets importados com os existentes? Clicar em "Substituir" apagará todos os tickets atuais.',
                            [
                                { text: 'Mesclar', value: 'merge', class: 'btn-save' },
                                { text: 'Substituir', value: 'replace', class: 'btn-delete' },
                                { text: 'Cancelar', value: null, class: 'btn-cancel' }
                            ]
                        );

                        if (mergeChoice === 'merge') {
                            const existingIds = new Set(tickets.map(t => t.id));
                            tickets.push(...importedTickets.filter(t => !existingIds.has(t.id)));
                        } else if (mergeChoice === 'replace') {
                            tickets = importedTickets;
                        } else {
                            return;
                        }

                        saveData();
                        renderBoard();
                        await showModal('Sucesso', 'Dados importados com sucesso!', [{ text: 'OK', value: 'ok', class: 'btn-save' }]);
                    } catch (error) {
                        await showModal('Erro', 'Erro ao importar arquivo: ' + error.message, [{ text: 'OK', value: 'ok', class: 'btn-cancel' }]);
                    } finally {
                        event.target.value = ''; 
                    }
                };
                reader.readAsText(file);
            };
            
            const handleAutoBackup = () => {
                if (tickets.length === 0) return; 

                const now = new Date();
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                const filename = `Backup-${hours}${minutes}.json`;

                const content = JSON.stringify(tickets, null, 2);
                const mimeType = 'application/json';

                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([content], { type: mimeType }));
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            };

            const handleAutoBackupSettings = async () => {
                const currentSetting = autoBackupCount > 0 ? autoBackupCount : 'desativado';
                const message = `
                    <p>A cada quantas edições o backup automático deve ser feito? (Atual: ${currentSetting})</p>
                    <p>Digite um número (ex: 5) ou 0 para desativar.</p>
                    <input type="number" id="backupCountInput" class="form-field" style="width: 100%; margin-top: 10px;" value="${autoBackupCount}">
                `;
                const choice = await showModal(
                    'Backup Automático',
                    message,
                    [
                        { text: 'Salvar', value: 'save', class: 'btn-save' },
                        { text: 'Cancelar', value: null, class: 'btn-cancel' }
                    ]
                );

                if (choice === 'save') {
                    const newCountStr = document.getElementById('backupCountInput').value;
                    if (newCountStr !== null) {
                        const newCount = parseInt(newCountStr, 10);
                        if (!isNaN(newCount) && newCount >= 0) {
                            autoBackupCount = newCount;
                            localStorage.setItem('todo-adm-autobackup-count', autoBackupCount.toString());
                            editCount = 0;
                            localStorage.setItem('todo-adm-edit-count', '0');
                            const successMessage = autoBackupCount > 0 ? `Backup automático configurado para cada ${autoBackupCount} edições.` : 'Backup automático desativado.';
                            await showModal('Sucesso', successMessage, [{ text: 'OK', value: 'ok', class: 'btn-save' }]);
                        } else {
                            await showModal('Erro', 'Por favor, insira um número válido.', [{ text: 'OK', value: 'ok', class: 'btn-cancel' }]);
                        }
                    }
                }
            };
            
            const archiveOldTasks = async () => {
                const thirtyDaysAgo = new Date();
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                let archivedCount = 0;

                tickets.forEach(ticket => {
                    if (ticket.status === 'Finalizado' && !ticket.archived && ticket.completionDate) {
                        if (new Date(ticket.completionDate) < thirtyDaysAgo) {
                            ticket.archived = true;
                            archivedCount++;
                        }
                    }
                });

                if (archivedCount > 0) {
                    saveData();
                    renderBoard();
                    await showModal('Sucesso', `${archivedCount} tarefa(s) concluída(s) há mais de 30 dias foram arquivadas.`, [{ text: 'OK', value: 'ok', class: 'btn-save' }]);
                } else {
                    await showModal('Aviso', 'Nenhuma tarefa concluída há mais de 30 dias para arquivar.', [{ text: 'OK', value: 'ok', class: 'btn-cancel' }]);
                }
            };

            const formatTimeAgo = (isoString) => {
                if (!isoString) return '';
                const now = new Date();
                const seenDate = new Date(isoString);
                const diffSeconds = (now - seenDate) / 1000;
                const diffMinutes = diffSeconds / 60;
                const diffHours = diffMinutes / 60;
                const diffDays = Math.floor(diffHours / 24);

                if (diffMinutes < 1) return 'agora';
                if (diffMinutes < 60) return `há ${Math.round(diffMinutes)} min`;
                if (diffHours < 6) return `há ${Math.round(diffHours)}h`;

                const isToday = now.toDateString() === seenDate.toDateString();
                if (isToday) {
                    const seenHour = seenDate.getHours();
                    if (seenHour < 12) return 'hoje de manhã';
                    if (seenHour < 18) return 'hoje à tarde';
                    return 'hoje à noite';
                }

                const yesterday = new Date();
                yesterday.setDate(now.getDate() - 1);
                if (yesterday.toDateString() === seenDate.toDateString()) {
                    return 'ontem';
                }

                return `há ${diffDays} dias`;
            };

            const updateAllVisibleTimestamps = () => {
                document.querySelectorAll('.ticket-card[data-id], .ticket-row[data-id]').forEach(el => {
                    const ticket = tickets.find(t => t.id === el.dataset.id);
                    if (ticket && ticket.lastSeen) {
                        const lastSeenEl = el.querySelector('.last-seen-text');
                        if (lastSeenEl) {
                            lastSeenEl.textContent = formatTimeAgo(ticket.lastSeen);
                        }
                    }
                });
            };

            // --- INICIALIZAÇÃO E LISTENERS ---
            addTicketFab.addEventListener('click', () => openModal('ticketModal'));
            document.querySelector('#ticketModal .close-button').addEventListener('click', () => closeModal('ticketModal'));
            document.querySelector('#ticketModal .btn-cancel').addEventListener('click', () => closeModal('ticketModal'));
            ticketForm.addEventListener('submit', handleFormSubmit);
            document.getElementById('deleteTicketBtn').addEventListener('click', handleDeleteTicket);
            document.getElementById('setApiKeyBtn').addEventListener('click', handleSetApiKey);
            document.getElementById('autoBackupBtn').addEventListener('click', handleAutoBackupSettings);
            archiveTasksBtn.addEventListener('click', archiveOldTasks);
            showArchivedToggle.addEventListener('change', renderBoard);
            smartFocusBtn.addEventListener('click', handleSmartFocus);


            generateTagsBtn.addEventListener('click', async () => {
                if (!googleApiKey) {
                    await showModal('Aviso', 'Por favor, defina sua Chave de API do Google nas configurações (⚙️) antes de usar as funções de IA.', [{ text: 'OK', value: 'ok', class: 'btn-cancel' }]);
                    return;
                }
                generateTagsBtn.textContent = 'Gerando...';
                generateTagsBtn.disabled = true;

                for (const ticket of tickets) {
                    if(!ticket.archived) await generateTagsForTicket(ticket);
                }
                
                saveData(false); // Salva sem contar como edição
                renderBoard();

                generateTagsBtn.textContent = 'Gerar/Atualizar Tags';
                generateTagsBtn.disabled = false;
                await showModal('Sucesso', 'Tags geradas/atualizadas para todos os cards!', [{ text: 'OK', value: 'ok', class: 'btn-save' }]);
            });


            document.querySelectorAll('.dropdown-toggle').forEach(btn => {
                btn.addEventListener('click', e => {
                    e.stopPropagation();
                    const dropdown = btn.nextElementSibling;
                    document.querySelectorAll('.dropdown-content').forEach(d => {
                        if (d !== dropdown) d.classList.remove('show');
                    });
                    dropdown.classList.toggle('show');
                });
            });
            
            window.addEventListener('click', (e) => {
                if (!e.target.closest('.dropdown')) {
                    document.querySelectorAll('.dropdown-content').forEach(d => d.classList.remove('show'));
                }
            });
            
            notificationList.addEventListener('click', (e) => {
                const target = e.target;
                if (target.closest('.notification-item') && !target.matches('select')) {
                    const ticketId = target.closest('.notification-item').dataset.ticketId;
                    const card = document.querySelector(`.ticket-card[data-id="${ticketId}"]`);
                    if (card) {
                        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        card.classList.add('flash');
                        setTimeout(() => card.classList.remove('flash'), 1000);
                    }
                    notificationList.classList.remove('show');
                }
            });
            notificationList.addEventListener('change', handleQuickStatusChange);


            document.getElementById('importBtn').addEventListener('click', () => document.getElementById('importFile').click());
            document.getElementById('importFile').addEventListener('change', handleImport);
            document.getElementById('exportSelect').addEventListener('change', e => { if (e.target.value) { handleExport(e.target.value); e.target.value = ''; } });

            kanbanBoard.addEventListener('click', (e) => {
                const copyTarget = e.target.closest('.copy-icon');
                if (copyTarget) {
                    e.stopPropagation();
                    const textToCopy = copyTarget.dataset.copy;
                    
                    const textArea = document.createElement("textarea");
                    textArea.value = textToCopy;
                    textArea.style.position = "fixed";
                    textArea.style.top = "-9999px";
                    textArea.style.left = "-9999px";
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        copyTarget.style.color = 'var(--status-finalizado)';
                        setTimeout(() => {
                            copyTarget.style.color = ''; // Reseta o estilo inline para a classe CSS assumir
                        }, 1000);
                    } catch (err) {
                        copyTarget.style.color = 'var(--priority-alta)';
                         setTimeout(() => {
                            copyTarget.style.color = ''; // Reseta o estilo inline para a classe CSS assumir
                        }, 1000);
                    }
                    document.body.removeChild(textArea);
                }
            });

            let searchTimeout;
            searchInput.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(renderBoard, 500); // Debounce para evitar buscas excessivas
            });
            searchMode.addEventListener('change', () => searchInput.classList.toggle('ai-active', searchMode.checked));
            filterStatus.addEventListener('change', renderBoard);
            showCompletedCheckbox.addEventListener('change', renderBoard);
            prioritySortToggle.addEventListener('change', renderBoard);

            loadData();
            renderBoard();
            requestNotificationPermission();
            setInterval(checkDeadlinesForDesktop, 60 * 1000 * 5); // Verifica prazos a cada 5 minutos
            setInterval(updateAllVisibleTimestamps, 60000); // Atualiza os tempos a cada minuto
        });
    </script>
</body>
</html>

